## 투 포인터 (Two Pointers)
### BOJ 1644 - 소수의 연속합  <https://www.acmicpc.net/problem/1644>  
  
  
  ![BOJ_1644 문제 캡쳐](https://user-images.githubusercontent.com/83392219/136643382-8e27b480-8df5-4179-8893-7f896195923f.JPG)
  
  
  
  
### (1) 문제에 사용된 알고리즘 ###
> 자연수가 주어졌을 때, 이 자연수를 **연속된 소수의 합**으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.  

1. 에라토스테네스의 체
2. 투 포인터

이 문제는 에라토스테네스의 체 문제를 풀어봤으면 쉬운 문제이다.<br><br> 

소수는 약수로 1과 자기 자신만 가지는 수를 의미한다.  
소수인 수 : 2(1, 2), 3(1& 3), 5(1, 5), ...  
소수가 아닌 수 : 0(0) , 1(1), 4(1,2,4), 6(1,2,3,6) ...  


#### 소수를 구하기 위한 코드 ####  
```
bool arr[4000001];
vector <int> eratos;


int main() {

	int N;	cin >> N;


	for (int i = 2; i <= sqrt(N); i++) {
		for (int j = i * i; j <= N; j += i) {
			if (arr[j] == 0) {
				arr[j] = 1;
			}
		}
	}

	for (int i = 2; i <= N; i++) {
		if (arr[i] == 0)
			eratos.push_back(i);
	}

	eratos.push_back(0);

```

소수가 아닌 0과 1은 제외하고, 소수인 2부터 주어진 숫자 N의 제곱근까지 숫자를 준다. <1차 for문>  
그런 다음 이 숫자가 소수가 아니면 배수 또한 제거해나간다. <2차 for문> <br>

1차적으로 이중 for문에서 소수와 소수가 아닌 수를 0, 1로 구분해주고  
2차적으로 소수만 벡터(eratos)에 넣는다.    

**마지막에 eratos.push_back(0)를 더해준 이유**는 벡터의 마지막 원소에 도달했을 때, end를 또 이동시키면 벡터의 범위를 벗어나게 돼 segmentation fault가 발생했기 때문이다.  
이걸 방지하고자 맨 마지막에 값이 0인 원소를 추가하였다. <br> <br>

투 포인터 알고리즘을 쓰기 위해 원소를 정렬해야 하지만, 이미 값이 정렬된 상태로 벡터에 추가되므로 따로 정렬은 사용하지 않아도 된다. 


#### 투 포인터 소스코드 ####   
```
	int sum = 0;
	int count = 0;
	int start = 0, end = 0;


	while (start <= end  && eratos[end] <= N) {	
		if (sum < N) {
			sum += eratos[end];
			if (end < eratos.size() - 2)
				end = end + 1;
		}
		else if (sum >= N) {
			sum -= eratos[start];
			start = start + 1;
		}
		if (sum == N) {
			count++;
		}
	}
	
	cout << count;

	return 0;
}
```  

투 포인터 알고리즘은 어떤 수 N이 주어지면,
start와 end (또는 left, right 등)를 조절해가면서 선형 시간 내에 '연속된 원소의 합(sum)'이 N이 되도록 찾는 것이다. <br><br>

start와 end를 이동시킬 때는 조건이 있는데..  
1. 연속된 원소의 합(sum)이 주어진 수 N보다 작으면  ☞☞ 계속해서 수를 더해 합이 N이 되는지 확인해야 하므로,  end 값을 1 증가시켜 범위를 늘린다.
2. sum이 N보다 크면  ☞☞ 이미 더해진 값들의 범위를 줄여야 하므로 start가 가리키는 값을 뺀 뒤, strat 값을 1 증가시켜 범위를 좁힌다.
3. sum이 N과 같다면  ☞☞ 가능한 경우를 한 개 찾은 것이므로 개수를 세준다. (count++)
4. 항상 start <= end를 만족해야 start를 줄이고, end를 늘리고 이런 것을 계속 반복할 수 있다.


### (2) 에러가 발생한 이유 ###
1. Segmentation fault
2. 시간 초과
