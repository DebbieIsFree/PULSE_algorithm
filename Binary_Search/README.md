## 이분 탐색 (Binary Search)
### BOJ 2110번   <https://www.acmicpc.net/problem/2110>
<hr/>   

문제가 잘 이해되지 않아서 다른 사람들이 작성한 코드를 많이 보면서 최대한 이해하려고 노력했습니다.<br> 특히 나동빈님 코드를 많이 참고했습니다.      


<span style="color:blue">1 문제</span>   

> 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.
> C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.

* 입력  

첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.  

* 출력  

첫째 줄에 **가장 인접한 두 공유기 사이의 최대 거리**를 출력한다.  <hr/>

<span style="color:blue">2 문제를 틀린 이유</span>     
   1.문제를 제대로 이해하지 못함   
   2. 이진 탐색 대상을 제대로 설정하지 못함  
    집(N)의 개수는 최대 200,000개라서 괜찮지만, 집의 좌표는 최대 1,000,000,000(10<sup>9</sup>)이라서 모든 경우를 다 탐색할 경우 시간 초과가 발생한다.   
    따라서 이진 탐색(O(log<sub>2</sub>n)을 사용해 탐색할 데이터 수를 줄이고, 최악의 경우에도 30번의 탐색만 하면 된다는 것까지는 이해했다.   
    하지만 '어떤 것, 어떤 값'을 이진 탐색의 대상으로 정해야 하는지 어려웠고 다양하게 시도해봤다.  <hr/>
  
   
   
<span style="color:blue">3 오답 해결 방법</span><br/>

   1. 처음에는 당연히 집의 좌표 (X<sub>i</sub>)를 탐색 대상으로 생각했지만, 이 문제는 '공유기가 설치된 두 집의 거리 차'의 최솟값과 최댓값을 
   각각 이분탐색의 left, right값으로 정해야 하고, 이 둘의 평균을 mid 값으로 해야 한다.   
   ~~또한 mid 값을 활용해 어떤 조건을 만족하면 mid이하 또는 mid 이상의 것은 고려하지 않는다는 것을 
   생각해야 한다.~~   
   2. 또 처음에는 공유기 개수(C)에 딱 맞게 구해야 된다고 생각했는데 (공유기 개수 C개를 설치하면 탐색을 종료한다고 생각했음)   
      다른 문제의 풀이들을 보니 이 문제는 공유기 개수 C에 딱 맞게 구하는 게 초점이 아니라, "가장 인접한 두 공유기 사이의 최대 거리"를 구하는 것이므로   
      그냥 공유기 위치를 C개 이상을 찾았으면 그냥 '최대 거리'를 구하는데 초첨을 맞추면 된다.<hr/>

<span style="color:blue">4 소스 코드</span>  

```
int	BinarySearch(int left, int right) {		// Max 최대 거리 차 반환
	int count = 1;		// 0..?s
	int Max = 0;		// location[0] ...?

	// 이분 탐색인데 맨 처음 집의 좌표를 왜 저장해야하고
	// 왜 다음 번 이분탐색 시 또 처음 (location[0])부터 다시 조사해햐하는가 이해가 안갔음
	// but, 거리 차를 늘리거나, 줄였을 때 이를 적용할 수 있는 경우를 찾기 위해
	// 맨 처음 좌표부터 다시 보는 것이었음..!

	while (left <= right) {
		int mid = (left + right) / 2;
		int available_from_this = location[0];

		for (int i = 0; i < N; i++) {
			// 값이 같다면 시작점(available_from_this)으로부터 mid만큼 떨어져 있다는 뜻이고
			// 값이 크다면 시작점으로부터 mid보다 더 멀리 떨어져 있다는 뜻
			// 그러므로 값이 같거나 큰 경우는 시작점(available_from_this)를 갱신해서
			// 더 가능한 경우가 있는지 탐색한다 
			// 시작점(available_from_this)을 갱신하는게 굉장히 중요하다
			// 왜냐하면 '시작점' ==> 조건을 만족한 첫번째 집(좌표)
			// 그러므로 시작점 이하에 위치한 집 (좌표) ==> 조건이 안맞았음
			// 따라서 제일 처음으로 조건을 만족한 시작점부터 그 이상의 위치에
			// 조건을 만족하는 집(좌표)가 있는지 찾기 위해 시작점 갱신 필요
			if (available_from_this + mid <= location[i]) {
				available_from_this = location[i];
				count++;
			}
		}
		

		// 공유기 개수 C만큼 위치를 다 찾았으면
		// '최대 거리 차'를 구하기 위해 '거리 차'를 늘려가며 가능한 경우를 탐색한다
		if (count >= C) {	// 거리차의 최솟값(left)을 증가시킴	
			left = mid + 1;
			Max = mid;		//  이때까지의 최대 거리차 mid를 저장 (이후 갱신 가능)
			cout << "\nmax : " << Max << endl;
		}
		// 공유기 개수 C만큼 위치를 다 찾지 못했다면
		// '거리 차'를 줄여가며 공유기 개수만큼 설치부터 한다.
		else {	// 거리차의 최댓값(right)를 감소시킴
			right = mid - 1;
		}
		
		// 거리 차 ==  mid (거리차 평균) ==  [(left(최소 거리차) + right(최대 거리차)) / 2 ]
		// 결국,  '거리 차'를 늘리거나 줄이는 것은
		// left, right를 조절하는 것
	}

	return Max;
}



int main() {
	int L, R;

	cin >> N >> C;
	
	if (N < 2)		// 어차피 N의 범위 : 2<= N <= 200,000이라서 괜찮
		return 0;   // 밑에 location[N-1]에 접근하기 위함

	for (int i = 0; i < N; i++) {
		cin >> location[i];
	}

	sort(location, location + N);


	//L = location[1] - location[0];		// 이게 왜 틀렸지...?
	L = 1;
	R = location[N - 1] - location[0];		
	
	cout << "[0], [1], [N-1] : " << location[0] << ", " << location[1]
		<< ", " << location[N - 1];


	cout << BinarySearch(L, R);

	return 0;
}
