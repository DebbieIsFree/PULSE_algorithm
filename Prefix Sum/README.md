# 누적합 (Prefix Sum) 
## BOJ 20002 - 사과나무 

<https://www.acmicpc.net/problem/20002>


* (1,1)부터 (N,N)까지 총이익 입력받기
* (1,1) ~ (N,N)까지 각각의 '누적합' DP[x][y] 구하기
* 빅오 : O(N**2)
```
	for (int x = 1; x <= N; x++) {
		for (int y = 1; y <= N; y++) {
			cin >> map[x][y];
			DP[x][y] = DP[x - 1][y] + DP[x][y - 1] - DP[x - 1][y - 1] + map[x][y];
		}
	}
```

```
int MAX = map[1][1];
```

* 문제조건
> 농부 형곤이가 가을을 맞아 사과를 수확하려는데, 땅주인 신영이가 "너는 과수원 내에 사과나무를 K × K 의 크기의 정사각형 모양으로만 수확해 가져갈 수 있어, 
> 이때 K는 1보다 크거나 같고 N보다 작거나 같은 정수라구! 나머지는 내가 먹을께! 하하!" 라고 통보했다.


* (a,b) ~ (x,y) '구간합' ('누적합'을 이용해서 '구간합' 구하기)
* 정사각형이 되도록 구간을 어떻게 줄 것인가 
  * 

```
for (int x = 1; x <= N; x++) {
	for (int y = 1; y <= N; y++) {
		for (int k = 0; k <= N; k++) {
			if (x + k <= N && y + k <= N) {
				int tmp = DP[x + k][y + k] - DP[x - 1][y + k] - DP[x + k][y - 1] + DP[x - 1][y - 1];
				MAX = max(MAX, tmp);	
			}
				
		}
	}
}
```






순서 없는 목록은 다음과 같이 작성할 수 있습니다.

* 깃 튜토리얼
  * 깃 Clone
  * 깃 Pull
  * 깃 Commit
    * 깃 Commit 1)
    * 깃 Commit 2)


강조는 다음과 같이 할 수 있습니다.

**치킨** 먹다가 ~~두드리기~~났어요. ㅠㅠ
