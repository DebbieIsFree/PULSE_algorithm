## 누적합 (Prefix Sum) 
### BOJ 20002 - 사과나무      <https://www.acmicpc.net/problem/20002>


* 좌표 (1,1)부터 (N,N)까지 총이익 map[x][y] 입력받기
* (1,1) ~ (x,y)까지 각각의 '누적합' DP[x][y] 구하기
* 빅오 : O(N**2)
* 2차원 배열 누적합 -> 1차원 배열의 누적합과 달리 알고리즘을 찾아서 공부해야 알 수 있다...!
```
	for (int x = 1; x <= N; x++) {
		for (int y = 1; y <= N; y++) {
			cin >> map[x][y];
			DP[x][y] = DP[x - 1][y] + DP[x][y - 1] - DP[x - 1][y - 1] + map[x][y];
		}
	}
```

```
int MAX = map[1][1];
```

* 문제조건
> 농부 형곤이가 가을을 맞아 사과를 수확하려는데, 땅주인 신영이가 "너는 과수원 내에 사과나무를 K × K 의 크기의 정사각형 모양으로만 수확해 가져갈 수 있어, 
> 이때 K는 1보다 크거나 같고 N보다 작거나 같은 정수라구! 나머지는 내가 먹을께! 하하!" 라고 통보했다.


* 시작점(a,b) ~ 끝점(x,y) '구간합' ('누적합'을 이용해서 '구간합' 구하기)
* 구간합을 사용하려면 시작점(a,b)과 끝점(x,y)가 있어야 하고, 이 공간이 '정사각형'이 되야하는데 이를 어떻게 줄 것인가
* -->  1 <= k <= N인 k를 도입 :  시작점(a,b)의 행,열에 똑같이 0, 1, 2, 3 ... N 값을 더해 정사각형으로 만들기 (0은 1*1 의미)
* 시작점 + K (a+k, b+k)가 배열의 범위 (N,N)을 넘지 않도록 범위 검사 

```
for (int x = 1; x <= N; x++) {
	for (int y = 1; y <= N; y++) {
		for (int k = 0; k <= N; k++) {
			if (x + k <= N && y + k <= N) {
				int tmp = DP[x + k][y + k] - DP[x - 1][y + k] - DP[x + k][y - 1] + DP[x - 1][y - 1];
				MAX = max(MAX, tmp);	
			}
				
		}
	}
}
```






순서 없는 목록은 다음과 같이 작성할 수 있습니다.

* 깃 튜토리얼
  * 깃 Clone
  * 깃 Pull
  * 깃 Commit
    * 깃 Commit 1)
    * 깃 Commit 2)


강조는 다음과 같이 할 수 있습니다.

**치킨** 먹다가 ~~두드리기~~났어요. ㅠㅠ
